//! Deterministic event ID generation.
//!
//! Event IDs are generated by hashing the event content, ensuring the same
//! logical event always produces the same ID. This makes imports idempotent.

use sha2::{Digest, Sha256};

/// Separator byte that cannot appear in field values (null byte).
const FIELD_SEPARATOR: u8 = 0;

/// Generate a deterministic event ID from event components.
///
/// The ID is the first 12 bytes of the SHA-256 hash of the inputs,
/// encoded as a 24-character hex string.
///
/// Fields are separated by null bytes to prevent collisions where field
/// boundaries could be ambiguous (e.g., source="ab", type="c" vs source="a", type="bc").
pub fn generate_event_id(source: &str, event_type: &str, timestamp: &str, data: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(source.as_bytes());
    hasher.update([FIELD_SEPARATOR]);
    hasher.update(event_type.as_bytes());
    hasher.update([FIELD_SEPARATOR]);
    hasher.update(timestamp.as_bytes());
    hasher.update([FIELD_SEPARATOR]);
    hasher.update(data.as_bytes());
    let result = hasher.finalize();
    // Take first 12 bytes as hex (24 chars) - enough for uniqueness
    hex::encode(&result[..12])
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn same_inputs_produce_same_id() {
        let id1 = generate_event_id(
            "remote.tmux",
            "tmux_pane_focus",
            "2025-01-25T14:00:00Z",
            "{}",
        );
        let id2 = generate_event_id(
            "remote.tmux",
            "tmux_pane_focus",
            "2025-01-25T14:00:00Z",
            "{}",
        );
        assert_eq!(id1, id2);
    }

    #[test]
    fn different_inputs_produce_different_ids() {
        let id1 = generate_event_id(
            "remote.tmux",
            "tmux_pane_focus",
            "2025-01-25T14:00:00Z",
            "{}",
        );
        let id2 = generate_event_id(
            "remote.tmux",
            "tmux_pane_focus",
            "2025-01-25T14:00:01Z",
            "{}",
        );
        assert_ne!(id1, id2);
    }

    #[test]
    fn id_is_24_hex_characters() {
        let id = generate_event_id("source", "type", "timestamp", "data");
        assert_eq!(id.len(), 24);
        assert!(id.chars().all(|c| c.is_ascii_hexdigit()));
    }

    #[test]
    fn id_is_stable_across_runs() {
        // This is a snapshot test - if the algorithm changes, this will fail
        let id = generate_event_id(
            "remote.tmux",
            "tmux_pane_focus",
            "2025-01-25T14:00:00Z",
            r#"{"pane_id":"%3","session_name":"dev","window_index":1}"#,
        );
        // Hard-coded expected value ensures determinism
        assert_eq!(id, "a14c45fe4b5b759067f930b9");
    }
}
